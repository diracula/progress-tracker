<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Goal Progress</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2>Progress Toward Goals (%)</h2>
<canvas id="chart" width="900" height="450"></canvas>

<script>
const SHEET_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vT4iNJsJrgRh_JtqIBnTLPQXUPS0d15rAbZDF3QHX7iYZd6Oe7aBMdt7faX1ZRL3x9tbD0R7H05Ahaj/pub?gid=1922078669&output=csv";

// Generate all days in 2026
function allDates2026() {
  const dates = [];
  let d = new Date("2026-01-01");
  const end = new Date("2026-12-31");
  while (d <= end) {
    dates.push(d.toISOString().slice(0, 10));
    d.setDate(d.getDate() + 1);
  }
  return dates;
}

fetch(SHEET_URL + "&t=" + Date.now())
  .then(res => res.text())
  .then(csv => {
    const rows = csv.trim().split("\n").map(r => r.split(","));
    const headers = rows[0].map(h => h.trim().toLowerCase());
    const body = rows.slice(1);

    const allDates = allDates2026();

    const datasets = [];
    const colours = [];

    for (let c = 0; c < headers.length; c++) {
      if (!headers[c].includes("date")) continue;

      // Find next non-empty header as value column
      let vCol = c + 1;
      while (vCol < headers.length && headers[vCol] === "") vCol++;
      if (vCol >= headers.length) continue;

      const name = rows[0][c].replace(/date/i, "").trim() || "Goal";

      let goal = null;
      const valuesByDate = {};

      body.forEach(r => {
        const d = r[c];
        const v = parseFloat(r[vCol]);
        if (!d || isNaN(v)) return;

        if (d.toLowerCase() === "goal") {
          goal = v;
        } else {
          valuesByDate[d] = v;
        }
      });

      const rawValues = allDates.map(d =>
        d in valuesByDate ? valuesByDate[d] : null
      );

      const baseline = rawValues.find(v => v !== null);
      const baselineIndex = rawValues.findIndex(v => v !== null);

      if (baseline === undefined || goal === null || goal === baseline) continue;

      const progress = rawValues.map(v =>
        v === null ? null : (v - baseline) / (goal - baseline) * 100
      );

      const colour = `hsl(${datasets.length * 67 % 360}, 70%, 50%)`;

      datasets.push({
        label: name,
        data: progress,
        borderColor: colour,
        backgroundColor: colour,
        borderWidth: 2,
        spanGaps: true
      });

      // Goal trajectory
      const goalLine = allDates.map((_, i) =>
        i < baselineIndex
          ? null
          : (i - baselineIndex) / (allDates.length - 1 - baselineIndex) * 100
      );

      datasets.push({
        label: name + " goal",
        data: goalLine,
        borderColor: colour,
        borderDash: [6, 6],
        borderWidth: 2,
        pointRadius: 0,
        tension: 0
      });
    }

    new Chart(document.getElementById("chart"), {
      type: "line",
      data: {
        labels: allDates,
        datasets
      },
      options: {
        responsive: true,
        interaction: {
          mode: "nearest",
          intersect: false
        },
        scales: {
          x: {
            ticks: {
              callback: (val, idx) => {
                const d = allDates[idx];
                return d.endsWith("-01") || d === "2026-12-31" ? d : "";
              }
            }
          },
          y: {
            title: {
              display: true,
              text: "Progress (%)"
            }
          }
        },
        plugins: {
          legend: {
            position: "chartArea",
            align: "start",
            labels: {
              filter: item => !item.text.endsWith(" goal")
            }
          }
        }
      }
    });
  });
</script>

</body>
</html>
